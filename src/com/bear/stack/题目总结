155：最小栈问题：如何在栈的基础上保存最小值，可以使用辅助栈或者栈中直接存放当前值和最小值来解决，也可以直接修改栈的实现存放最小值
    这都使用了额外的空间，我们可以观察两个值之间的关系。存放差值来确定最小值和原值，很巧妙！

20: 括号问题：括号的特性是先来的后比较，跟栈的后进先出一致.因为括号匹配都是偶数，所以可以先用长度剪枝一下。

739: 每日温度问题：要找到比当前元素大的下一个元素。（下一个更大，下一个更小之类存在单调性）
    1. 暴力解法是双重循环，相当于是跟后面的元素比较，每次都会有大量的重复比较。
    2. 单调栈使用辅助空间记录元素，相当于是跟之前的元素比较。相当于只会比较一次。

581：最短无序子数组：
    1. 将原数组看成三段，A+B+C,A和C是和排序后的位置是一致的。所以可以使用排序+前后双指针（找到A和C的边界）来解决
    2. 一次遍历，（B中的最小值比A大，最大值比C小）好难想。从左到右维护右边界，从右到左维护左边界。
    3. 两个辅助单调栈，左边单点递增维护左边界，右边单点递减维护右边界

394: 字符串解码
    1. 遇到不是]的直接push入栈，遇到]首先持续出栈到[,然后把中括号弹出，在持续出栈得到数字，运算之后入栈即可。

234: 回文链表
    1. 遍历使用字符串拼接值，然后翻转比较即可
    2. 如果想要找到O(1)空间复杂度的解法，就是翻转后半部分链表，然后比较即可

225: 用队列实现栈: 究其本质，非常相似，
    1. 题目要求用两个队列实现栈，分析栈和队列的性质，一个后进先出，一个先进先出，所以我们定义一个队列为输入队列（也可以用一个临时遍历），一个为输出队列。
    输入队列接受输入，然后将输出队列的元素依次插入到其后面，再复制给输出队列。因为来了新元素之后将原有队列元素插入其后方。即可满足条件。
    2. 使用一个队列完成，分析性质，每次入队列都要把之前的队列元素依次插入新元素之后即可。

232: 用栈实现队列：
    1. 用两个栈，一个栈用来输入，一个栈用来输出，当输出栈没有元素当时候，输入栈全部输出到输出栈中即可，满足了先进先出。
    （先进到在输入栈到栈底，挪到输出栈就会在输出栈到栈顶。）

682：棒球比赛
    1. 基本栈运用题。

71：简化路径
    1. 因为路径是否简化是跟后续的..有关，所以使用栈暂存之前的路径即可，后续拼接。使用split分割

150：逆波兰表达式
    1. 基础栈运用题
    2. 数组模拟栈,定义索引栈顶指针即可。

496: 下一个更大元素：（这种类似下一个更大，下一个更小的，都可以使用单调栈，因为具备单调性）
    1. 单调栈，因为要在原数组中找到第一个更大的元素，所以维护一个单点递减的单调栈，当元素比栈顶元素大的时候连续出栈即可。

503：下一个更大元素II:
    1. 单调栈+循环数组，下标取模即可(我傻逼的两个for),

316：去除重复字母：三个要求：1. 去重 2 相对顺序不变 3 字典序号最小（维护一个单调递增的栈，如果遇到字典序更小的，依次从栈顶判断后面还有没有，有就出栈）
    1. 使用布尔数组去重，使用单调栈保持相对顺序不变，使用计数数组保持字典序最小。

402: 移掉k位数字
    1. 从前到后维护一个单调递增的单调栈（双端队列不需要翻转），如果遇到更小的，一次弹出即可，如果数字是升序的，遍历结束之后还没有移除完k个数字，则再移出后几位。

622: 设计循环队列:(循环队列中，索引增加为:(index+1)%capacity, 索引减小为：（index-1+capacity）%capacity )
    1. 数组实现，设置两个索引，一个指向队头，一个指向队尾的下一个位置，队列为空是头=尾，队列满是（尾+1）%长度=头，一般空一个位置来区分队空还是队满
    2. 链表实现，两个指针，一个头指针，一个尾指针，一个变量保存大小，一个变量保存队列长度。

641: 设计循环双端队列
    1. 数组实现
    2. 链表实现，需要使用双向链表，因为单向链表尾删不能在O（1）的时间复杂度内。




队列可以实现栈的功能，栈要实现队列的功能则需要使用两个栈。一个输入，一个输出，(为什么循环队列会牺牲一个位置不存储数据，因为有n位的数组要表示n+1中关系
，队空和队中有1到n个元素，但是我们表示是用队头和队尾的距离，距离只有n个表示，所以要么在使用一个变量size来表示队空)